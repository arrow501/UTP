<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <meta name="author"
 content="Krzysztof Barteczko"> <meta name="description"
 content="Uniwersalne techniki programowania"> <meta name="copyright"
 content="(c) Krzysztof Barteczko PJWSTK 2010"> <link rel="stylesheet"
 type="text/css" href="../STYLE/common.css"> <title>JavaBeans</title></head>
<body><br>
<br>
<div align="center"><h1>JavaBeans</h1>
</div><br>
<hr><i></i><span style="font-style: italic;">Termin JavaBeans
wi¹¿e siê&nbsp; z koncepcj¹ budowania
programów z gotowych, ³atwo dostosowywanych do konkretnych potrzeb,
komponentów
programowych. Idea to niezwykle kusz¹ca, ale jednoczeœnie – z
niewiadomych
powodów – owiana nimbem "wy¿szego wtajemniczenia".&nbsp; W bardzo
krótkim wprowadzeniu
do JavaBeans zobaczymy, ¿e nie ma tu nic tajemniczego ani trudnego, a
korzyœci wi¹¿¹ siê nie tylko z ponownym uzyciem gotowych komponentów,
ale równie¿ z mo¿liwoœci¹ tworzeniu uniwersalnych kodów dziêki
machanizmowi nas³uchu zmian w³aœciwoœci. </span> <hr>
<a name="JavaBeans.1"></a><h2>1. Pojêcie JavaBean</h2>
<br>
<div class="def"><b>JavaBean</b> - (bean – ziarno) – to programowy
komponent "wielokretnego
u¿ytku", którego w³aœciwoœci i funkcjonalnoœæ mog¹ byæ odczytywane
i/lub
zmieniane uniwersalnymi œrodkami programistycznymi.</div><br>
<br>
Uwaga: JavaBean oznacza zarówno obiekt, jak i klasê tego obiektu.
Rozró¿nienie
zawsze jasno wynika z kontekstu. O JavaBean bêdziemy mówiæ krócej
"ziarno".<br>
<br>
Co oznacza powy¿sza definicja?<br>
Gdy wbudowujemy zewnêtrzny komponent-ziarno do naszego programu, mamy
do
dyspozycji œrodki programistyczne, które pozwalaj¹ uzyskaæ o nim
informacje:<br>
<br>
<ul><li>jakie ma w³aœciwoœci? jakie metody s³u¿¹ do ich pobierania
i ustalania? </li><li>jakie obs³uguje zdarzenia? jakie zdarzenia mog¹
siê mu przytrafiaæ? </li><li>jakie metody udostêpnia otoczeniu
(eksportuje)? </li></ul>
Uniwersalnoœæ sposobów odczytywania i/lub zmieniana charakterystyk
obiektu-ziarna opiera siê na:<br>
<ul><li>uzgodnionym protokole. dotycz¹cym informacji o ziarnie
(standardowe wzorce deklaracji metod i/lub klasy informacyjne) </li><li>standardowych
œrodkach pobierania informacji (introspekcja - realizowana przez klasê
Introspector z pakietu java.beans) </li><li>standardowych œrodkach
dostosowania obiektu </li></ul>
<br>
<a name="JavaBeans.2"></a><h2>2. W³aœciwoœci i akcesory</h2>
Ziarna maj¹ w³aœciwoœci (atrybuty).<br>
<br>
<div class="def">Dostêp do w³asciwoœci zapewniaj¹ metody
klasy-ziarna nazywane akcesorami..<br>
Akcesor pobieraj¹cy w³aœciwoœci nazywa siê getter, a ustalaj¹cy –
setter.</div><br>
<br>
Wyró¿niamy w³asciwoœci <b>proste </b>(w tym binarne) oraz
w³aœciwoœci <b>indeksowane</b>.<br>
W³aœciwoœci proste maj¹ jedn¹ wartoœæ, w³aœciwoœci indeksowane – wiele
wartoœci, przedstawianych jako tablica.<br>
<br>
<div class="syntax">Standardowe wzorce deklaracji akcesorów s¹
nastêpuj¹ce<br>
<br>
Dla&nbsp; prostej (niebinarnej) w³asciwoœci o nazwie NNN i typie Typ<br>
<br>
getter: Typ getNNN() <br>
setter: void&nbsp; setNNN(Typ)<br>
<br>
np. dla ziarna javax.swing.JButton i w³asciwoœci background mamy <br>
getter: Color getBackground()<br>
&nbsp;i setter: void setBackground(Color).<br>
<br>
Dla w³aœciwoœci binarnej o nazwie NNN:<br>
<br>
getter: boolean isNNN()<br>
setter: void setNNN(boolean)<br>
<br>
np. boolean isVisible(), setVisible(boolean)<br>
<br>
Dla w³aœciwoœci indeksowanej o nazwie NNN, której wartoœci
reprezentowane s¹ jako tablice elementów typu Typ:<br>
&nbsp;<br>
getter elementu:&nbsp; Typ getNNN(int) // zwraca wartoœæ&nbsp; podanego
indeksu w³aœciwoœci<br>
setter elementu: vois setNNN(int, Typ) // ustala wartoœæ&nbsp; podanego
indeksu w³aœciwoœci<br>
<br>
getter tablicy: Typ[] getNNN()<br>
setter tablicy: void setNNN(Typ[])<br>
</div><br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>zwi¹zane (bounded)</b>. <br>
<br>
O zmianie zwi¹zanej w³aœciwoœci ziarna mog¹ byæ zawiadamiane inne
komponenty i reagowaæ na tê zmianê. <br>
<br>
W³aœciwoœci ziarna mog¹ byæ <b>ograniczane (constrained)</b>.<br>
Ograniczana w³aœciwoœæ – to taka, o której zmianie powiadamiane s¹
zainteresowane
inne komponenty i s¹ pytane o zgodê na tê zmianê. Jeœli którykolwiek z
komponentów
nie da takiej zgody (zawetuje zmianê)&nbsp; – zmiana nie dochodzi do
skutku.<br>
<br>
Setter zwi¹zanej i/lub ograniczanej w³aœciwoœci ma obowi¹zek
wygenerowaæ zdarzenie klasy <b>PropertyChangeEvent</b>..<br>
<br>
Klasy-ziarna , maj¹ce zwi¹zane w³aœciwoœci mus¿¹ dostarczyæ metody
przy³¹czania s³uchaczy zmian w³aœciwoœci: <b>addPropertyChangeListener(PropertyChangeListener)</b><br>
<br>
Klasy-ziarna, maj¹ce ograniczane w³aœciwoœci, musz¹
dostarczyæ&nbsp; metody <b>addVetoableChangeListener(VetoableChangeListener)</b>.<br>
<br>
Ziarna mo¿emy wykorzystywaæ, mo¿emy te¿ je tworzyæ (w znaczeniu:
definiowaæ klasê ziarna)<br>
<br>
Tworzenie ziarna (jako klasy) wymaga zdefiniowania klasy,&nbsp;
która:<br>
<ul><li>stosuje ogólnie przyjête wzorce sygnatur metod&nbsp; i/lub
uzupe³niona jest
przez dodatkow¹ specjaln¹ klasê opisuj¹c¹ "niestandardowe" informacje o
ziarnie
(implementacja interfejsu BeanInfo) </li><li>zapewnia serializacjê
obiektów</li><li>zawiera konstruktor bezparametrowy </li><li>uzwglêdnia
dzia³ania w œrodowisku wielow¹tkowym (do obiektu klasy mo¿e
równoczeœnie odwo³ywaæ siê kilka w¹tków) </li></ul>
<br>
<a name="JavaBeans.3"></a><h2>3. Nas³uch i wetowanie zmian w³aœciwosci</h2>
Zmiana w³aœciwoœci zwi¹zanej lub ograniczanej powinna generowaæ
zdarzenie typu <b>PropertyChangeEvent</b>.<br>
<br>
Komponenty (obiekty) zainteresowane w œledzeniu zmian&nbsp; tej
w³asciwoœci&nbsp; musz¹ implementowaæ interfejs <b>PropertyChangeListener</b>.&nbsp;
W ten sposób staj¹ siê s³uchaczami zmian w³aœciwoœci.. <br>
Komponenty, które mog¹ wetowaæ zmiany w³aœciwoœci musz¹ implementowaæ
interfejs <b>VetoableChangeListener</b> (bêd¹ wiêc s³uchaczami zmian
w³aœciwoœci ograniczonych i bêdê mia³y mo¿liwoœæ wetowania tych zmian).<br>
<br>
Zdarzenie typu PropertChangeEvent mo¿emy zapytaæ o:<br>
<ul><li>nazwê w³aœciwoœci -&nbsp; String getPropertyName()</li><li>star¹
wartoœæ w³asciwoœci&nbsp; (przed zmian¹) – Object getOldValue()</li><li>now¹
wartoœæ w³asciwoœci – Object getNewValue() </li></ul>
Interfejs <b>PropertyChangeListener</b> ma jedn¹ metodê:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; public void
propertyChange(PropertyChangeEvent)</b><br>
<br>
W implementacji tej metody, dowiaduj¹c siê o zmianach w³aœciwoœci,
mo¿emy na nie odpowiednio reagowaæ.<br>
<br>
Równie¿ interfejs <b>VetoableChangeListener</b> ma jedn¹ metodê: <b>vetoableChange(...)</b>
z argumentem–zdarzeniem typu PropertyChange. W jej implementacji , gdy
dowiemy
siê ju¿ wszystkich niezbêdnych szczegó³ow o zmianie – mo¿emy j¹
zawetowaæ.<br>
<br>
<b>Wetowanie zmiany</b>&nbsp; odbywa siê na zasadzie zg³oszenia
wyj¹tku <b>PropertyVetoException</b>, zatem deklaracja metody
vetoableChange wygl¹da nastêpuj¹co:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; public void
vetoableChange(PropertyChangeEvent e)&nbsp; <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throws
PropertyVetoException<br>
</b><br>
a w jej implementacji – gdy po sprawdzeniu waroœci w³aœciwoœci
chcemy zg³osiæ veto – sygnalizujemy wyj¹tek: <b>throw new
PropertyVetoException(...)</b>.<br>
<br>
<b>S³uchacze</b> zmian&nbsp; w³aœciwoœci&nbsp; zwi¹zanych (jak
zawsze w Javie) mus¿¹
byæ przy³¹czeni do Ÿród³a zdarzenia., którym jest&nbsp; w tym przypadku
ziarno.&nbsp;
<br><br>
Przy³¹czenie staje siê mo¿liwe, jesli w klasie-ziarnie
zdefiniowano metodê <b>addPropertyChangeListener(...)</b><br>
Musi te¿ byæ zdefiniowana metoda <b>removePropertyChangeListener</b>,
od³aczaj¹ca s³uchacza.<br>
<br>
To samo dotyczy nas³uchu zmian w³aœciwoœci ograniczanych: klasa
zaiarno
musi dostarczyæ&nbsp; metody przy³¹czenia s³uchacza:&nbsp; <b>addVetoableChangeListener</b>
oraz metody od³¹czania s³uchacza:&nbsp; <b>removeVetoableChangeListener</b>.<br>
<br>
<font color="#ff0000"><b>Obowi¹zkiem klasy ziarna, która
implementuje zwi¹zane i/lub ograniczane w³aœciwoœci
jest równie¿ dostarczenie odpowiednich definicji setterów dla tych
w³aœciwoœci.
<br>
W setterach nale¿ey&nbsp; generowaæ zdarzenie
PropertyChangeEvent&nbsp; i propagowaæ go poœród przy³¹czonych
s³uchaczy.<br>
</b></font><br>
W pakiecie java.beans znajduj¹ siê dwie klasy narzêdziowe,&nbsp;
znacznie u³atwiaj¹ce
wykonanie tych zadañ: PropertyChangeSupport i VetoableChangeSupport.<br>
Klasy dostarczaj¹ metod&nbsp; generowania zdarzeñ i propagacji zdarzeñ
zmian:<br>
<ul><li>w³aœciwoœci zwi¹zanych -&nbsp; firePropertyChange </li><li>w³aœciwoœci
ograniczanych -&nbsp; fireVetoableChange s³uchaczy.</li><li>a tak¿e
metod przy³¹czanai i od³¹czania s³uchaczy tych zmian (addNNNListener,
removeNNListener).</li></ul>
Konstruktory tych klas maj¹ jako argument&nbsp; referencjê do
obiektu-ziarna.<br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci zwi¹zanej
jest nastêpuj¹cy:</b></u><br>
<br>
<pre>class Ziarno .... {

  //wsparcie
  private PropertyChangeSupport chg = new PropertyChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc zwi¹zana o nazwie "text"
  ...
// setter
synchronized void setText(String newTxt) { // pamiêtamy o wielow¹tkowoœci!

    String oldTxt =  text;   // stara wartoœæ
    text = newTxt;           // ustalenie nowej wartoœci
     // powiadomienie
    chg.firePropertyChange("text", oldTxt, newTxt);
}
....

// metody dodawania i usuwania s³uchaczy
public synchronized void addPropertyChangeListener(PropertyChangeListener l) {
 chg.addPropertyChangeListener(l);
 }

public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
 chg.removePropertyChangeListener(l);
 }
...
}

</pre>
<br>
Implementacja w³aœciwoœci ograniczanych musi uzwglêdniaæ mo¿liwoœæ
zawetowania zmiany przez któregoœ ze s³uchaczy. <br>
<br>
<u><b>Schemat postêpowania przy implementacji w³aœciwoœci
ograniczanej jest nastêpuj¹cy:</b></u><br>
<br>
<pre>class Ziarno .... {

  //wsparcie
  private VetoableChangeSupport veto = new VetoableChangeSupport(this);

  String text;    // to bêdzie w³aœciwoœc ograniczana o nazwie "tekst"
  ...
// setter

synchronized void setText(String newTxt)  throws PropertyVetoException
 {
    String oldTxt =  text;  // stara wartoœæ

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     //  przez metodê wywo³uj¹c¹ setText

     veto.fireVetoableChange("tekst", oldTxt, newTxt);

     // Tylko jeœli nikt nie zawetowa³ zmiany:

     text = newTxt;   // ustalenie nowej wartoœci
}
....
// metody dodawania i usuwania s³uchaczy

public synchronized void addVetoableChangeListener(PropertyChangeListener l) {
 veto.addVetoableChangeListener(l);
 }

public synchronized void removeVetoableChangeListener(PropertyChangeListener l) {
 veto.removeVetoableChangeListener(l);
 }
...
}

<b>// Uwaga: wsystkie klasy  zdarzeniowe i interfejsy nas³uchu
// dla w³aœciwoœci znajduj¹ siê w pakiecie java.beans.
</b>
</pre>
<br>
<br>
<a name="JavaBeans.4"></a><h2>4. JavaBean - przyk³ad praktyczny</h2>
Bêdziemy budowaæ klasê-licznik jako JavaBean. Klasê nazwiemy <b>Counter</b>.<br>
Licznik bêdzie mia³ jedn¹ w³aœciwoœæ o nazwie <b>count</b> (stan
licznika).<br>
W wersji pierwszej uczynimy tê w³aœciwoœæ zwi¹zan¹ (bounded), w&nbsp;
wersji drugiej – zwi¹zan¹ i ograniczon¹ (constrained).<br>
<br>
 Przy budowie aplikacji zastosujemy koncepcjê&nbsp;
"Model-View-Controller".
<br>
<br>
Sama klasa Counter odzwierciedla logikê dzia³ania licznika ("<b>model</b>
"). Obiekty tej klasy "s¹ niewidzialne", a zatem&nbsp; ¿eby zobaczyæ
licznik musimy
stworzyæ dodatkow¹ klasê, która zdefiniuje widok licznika&nbsp; (<b>view</b>).<br>
Nazwiemy j¹ <b>CounterView</b>. Warto zwróciæ uwagê: separacja kodu
jest
korzystna – widok uniezale¿niamy od modelu, a model od widoku, w ten
sposób
mo¿emy mieæ np. wiele widoków licznika, lub zmieniaæ model nie
zmieniaj¹c
widoku.<br>
<br>
Komunikacja miêdzy modelem i widokiem bêdzie siê odbywaæ na
zasadzie nas³uchu
zmian w³aœciwoœci (zmian w³aœciwoœci count) czyli obiekt klasy
CounterView
bêdzie te¿ s³uchaczem zmian w³aœciwoœci (PropertyChangeListener).<br>
<br>
Musimy te¿ mieæ jakieœ œrodki zmiany stanu licznika. Interakcjê
u¿ytkownika z modelem/widokiem zapewnia tzw. kontroler.<br>
Widzieliœmy, ¿e w komponentach Swingu (w naturalny dla nich sposób)
kontroler
po³¹czony jest z widokiem. Tu jednak odseparujemy jego kod od widoku,
tworz¹c
klasê <b>CounterControlGui</b>, zapewniaj¹c¹ interfejs interakcji z
licznikiem.. Widok zostanie dodany do tego GUI (ale kody obu klas bêd¹
odseparowane).<br>
<br>
W wersji drugiej – kiedy w³aœciwoœæ count bêdzie zwi¹zana i
ograniczana musimy
dostarczyæ obiektu-nadzorcy, który bêdzie sprawdza³ czy zmiana
w³aœciwoœci
jest dopuszczalna i jeœli stwierdzi, ¿e nie – bêdzie wetowa³ tê zmianê.
Odpowiedni¹
klasê nazwiemy <b>CounterLimitator</b>.<br>
<br>
W metodzie main(...) klasy Main, w której nasza aplikacja zacznie
¿ycie stworzymy
wszystkie odpowiednie obiekty w/w klas i ustanowimy niezbêdne
po³¹czenia
miêdzy nimi.<br>
<br>
W sumie logika dzia³ania aplikacji bêdzie wygl¹daæ tak:<br>
<br>
<br>
<img src="images/Counter1.jpg" alt="r" border="1" height="224"
 width="597"><br>
<br>
Zaczynamy od wersji pierwszej, ubo¿szej, w której klasa Counter
daje przyk³ad
typowego programowania JavaBean z wlaœciwoœci¹ zwi¹zan¹:<br>
<br>
<pre>// Klasa Counter

import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class Counter implements Serializable {

  private int count = 0;    // w³aœciwoœæ count

  // Pomocniczy obiekt do prowadzenia listy s³uchaczy zmian w³aœciwoœci oraz
  // propagowania zmian  wœród zarejestrowanych z³uchaczy
   private PropertyChangeSupport propertyChange = new PropertyChangeSupport(this);


  // Konstruktory

  public Counter() {
    this(0);
  }

  public Counter(int aCount) {
    setCount( aCount );
  }


  // Metody przy³¹czania i od³¹czania s³uchaczy zmian w³aœciwoœci

  public synchronized void addPropertyChangeListener(PropertyChangeListener listener) {
    propertyChange.addPropertyChangeListener(listener);
  }

  public synchronized void removePropertyChangeListener(PropertyChangeListener l) {
    propertyChange.removePropertyChangeListener(l);
  }

  // Proste metody zwiêkszania i zmniejszania licznika

  public void increment() {
    setCount(getCount()+1);
  }

  public void decrement() {
    setCount(getCount()-1);
  }


  // Getter w³aœciwoœci "count"
  public int getCount() {
    return count;
  }

  // Setter w³aœciowœci "count"
  public synchronized void setCount(int aCount) {
    int oldValue = count;
    count = aCount;

    // wywo³anie metody firePropertChange z klasy PropertyChangeSupport
    // powoduje wygenerowanie zdarzenia PropertyChangeEvent i rozpropagowanie
    // go wœród wszystkich przy³¹czonych s³uchaczy, ale tylko wtedy, gdy nowa
    // wartoœæ w³aœciwoœci ró¿ni siê od starej wartoœci

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                            new Integer(aCount));
  }

}
</pre>
Widok licznika przedstawimy jako etykietê - klasa ta jednoczeœnie
bêdzie
nas³uchiowaæ zmian w³aœciwoœci count i odpowiednio do tego zmieniaæ
tekst
na etykiecie (a tak¿e wyprowadzaæ informacje o zmianach w³aœciwoœci
count
na konsolê).<br>
<br>
<pre>//Klasa CounterView
//Widok licznika przedstawiamy w postaci etykiety

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;


public class CounterView extends JLabel implements PropertyChangeListener {


  // Konstruktor domyœlny: inicjalizuje etykietê tekstem "0"
  CounterView()  {
     this("0");
  }

  // Konstruktor inicjalizuj¹cy etykietê podanym tekstem
  CounterView(String lab) {
     super(lab);
     setOpaque(true);   // etykieta nie przezroczysta
       // ramka
     setBorder(BorderFactory.createLineBorder(Color.black));
       // rozmiary i wyrównanie tekstu
     setPreferredSize(new Dimension(75, 40));
     setHorizontalAlignment(CENTER);
  }

  // ob³uga zdarzenia PropertyChange
  public void propertyChange(PropertyChangeEvent e)  {
    Integer oldVal = (Integer) e.getOldValue(),
           newVal = (Integer) e.getNewValue();
    System.out.println("Value changed from " + oldVal + " to " + newVal);
    setText("" + newVal + "");  // pokazanie na etykiecie nowego stanu licznika
   }


}
</pre>
Klasa kontrolera - CounterControlGui dostarcza dwóch przycisków
(zwiêksz,
zmniejsz licznik) oraz pole tekstowe, w którym mo¿na wpisaæ wartoœæ
licznika
(ENTER)<br>
Zarówno klikniêcie w przyciski jak i ENTER na polu tekstowym powoduje
powstanie
zdarzenia Action, które tu (w tej klasie) obs³ugujemy ustalaj¹c
nowe&nbsp;wartoœci
licznika za pomoc¹ metod incremet() decrement() i setCount(...) z klasy
&nbsp;Counter.
<br>
<br>
<pre>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;

public class CounterControlGui extends JFrame implements ActionListener {

  Counter counter;
  JButton binc = new JButton("Increment");
  JButton bdec = new JButton("Decrement");
  JTextField txt = new JTextField(10);

  // Konstruktor otrzymuje jako argumenty obiekty typu Counter i CounterView
  // Pierwszy jest nam potrzebny do komunikacji z licznikiem, drugi - widok
  // wbudujemy w to GUI.

  CounterControlGui(Counter c, CounterView clab)  {
    counter = c;
    Container cp = getContentPane();
    cp.setLayout(new FlowLayout());
    binc.addActionListener(this);
    cp.add(binc);
    cp.add(clab);
    bdec.addActionListener(this);
    cp.add(bdec);
    txt.addActionListener(this);
    cp.add(txt);
    setDefaultCloseOperation(3);
    pack();
    show();
  }


  // Obs³uga akcji
  public void actionPerformed(ActionEvent e)  {
      if (e.getSource() == txt)  {
         int n = 0;
         try  {
            n = Integer.parseInt(txt.getText());
         } catch (NumberFormatException exc)  { return; }
         counter.setCount(n);
         return;
      }
      String cmd = e.getActionCommand();
      if (cmd.equals("Increment")) counter.increment();
      else if (cmd.equals("Decrement")) counter.decrement();
      else System.out.println("Unrecognized command");
  }

}
</pre>I
wreszcie lacz¹ca wszystko klasa Main, która inicjuje dzia³anie
aplikacji.<br>
<br>
<pre>public class Main {

 public static void main(String[] args)  {

   // Tworzymy obiekty: licznik i jego widok
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());

   // Rejestrujemy widok jako s³uchacza zmian licznika
   counter.addPropertyChangeListener(counterView);

   // Tworzymu GUI kontrolera i pokazujemy go
   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
<br>
Diza³anie aplikacji ilustruje rysunek oraz komunikaty na konsoli,
powsta³e
po kolejnych klilniêciach w przyciski Incremenet i Decrement oraz
wprowadzeniu
liczby 23 w polu tekstowym i naciœnieciu ENTER.<br>
<br>
<img src="images/Counter1-v1.jpg" alt="r" border="1" height="75"
 width="407">
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to 1<br>
Value changed from 1 to 0<br>
Value changed from 0 to 23<br>
</div><br>
<br>
<b>Wersja 2</b><br>
<br>
W wersji drugiej chcemy dodaæ obiekt – nadzorcê, który bêdzie
sprawdza³ czy
zmiana licznika jest dopuszczalna, a jeœli nie to bêdzie wetowa³ tê
zmianê.<br>
Mechanizm wetowania polega na sygnalizowaniu wyj¹tku
PropertyVetoException.<br>
Wyj¹tek ten bêdzie sygnalizowany przez obiekt-nadzorcê, który jest
jednoczesnie
s³uchaczem zmian wartoœci w³aœciwoœci ograniczonych
(VetoableChangeListener).
<br>
<br>
Klasa definiuj¹ca obiekty nadzoruj¹ce nasz licznik wygl¹da tak.<br>
<br>
<pre>import java.beans.*;

public class CounterLimitator implements VetoableChangeListener {

// minimalne i makszymalne dopuszczalne wartoœci licznika
private int min, max;

CounterLimitator(int minLim, int maxLim)  {
  min = minLim;
  max = maxLim;
}

// Obs³uga zdarzenia vetoableChange
// metoda mo¿e sygnalizowaæ PropertyVetoException
public void vetoableChange(PropertyChangeEvent e)
            throws PropertyVetoException {
   Integer newVal = (Integer) e.getNewValue();
   int val = newVal.intValue();
   // Sprawdzamy, czy zmiana  licznika jest dopuszczalna,
   // jeœli nie – sygnalizujemy wyjatek  PropertyVetoException
   if (val &lt; min || val &gt; max)
      throw new PropertyVetoException("Niedopuszczalna zmiana wartoœci", e);
   }

}

</pre>
W klasie Counter musimy poczyniæ zmiany, po to by w³aœciwoœæ count by³a
zarazem zwi¹zana i ograniczana.<br>
Wykorzystamy podobn¹ do PropertyChangeSupport klasê pomocnicz¹
VetoableChangeSupport<br>
Obiekt tej klasy nazwiemy vetos, dostarczymy te¿ metod przy³¹czania i
od³¹czania s³uchaczy zmian ograniczanych.<br>
<br>
<pre>public class Counter {

//...

private VetoableChangeSupport vetos = new VetoableChangeSupport(this);

public synchronized void addVetoableChangeListener(VetoableChangeListener l) {
	vetos.addVetoableChangeListener(l);
}

public synchronized void removeVetoableChangeListener(VetoableChangeListener l) {
	vetos.removeVetoableChangeListener(l);
}

// ...
}
</pre>
<br>
Zmianie ulegnie te¿ metoda setCount.<br>
<br>
<pre>public class Counter {

//...
public synchronized void setCount(int aCount)
                         throws PropertyVetoException {

     int oldValue = count;

     // wywo³ujemy metodê fireVotoableChange, która z kolei
     // wywo³uje metody vetoableChange zarejestrowanych s³uchaczy
     // jeœli któraœ z nich zg³asza veto, setter koñczy dzia³anie
     // a wyj¹tek PropertyVetoException jest przekazywany do obs³ugi
     // przez metodê wywo³uj¹c¹ setCount
     // (co zaznaczyliœmy w nag³ówku metody przez
     // throws PropertyVetoException)

    vetos.fireVetoableChange("count", new Integer(oldValue), new Integer(aCount));

    // tylko jeœli nikt nie zawetowa³

    count = aCount;  // ustalamy now¹ wartoœæ licznika

    // ... powiadamiamy nas³uchuj¹cych zmiany w³aœciwoœci count

    propertyChange.firePropertyChange("count", new Integer(oldValue),
                                       new Integer(aCount));
}

//...
}
</pre>
Poniewa¿ metody increment, decrement i konstruktory wywo³uj¹ metodê
setCount,
to w sygnaturach tych metod i konstruktorów musimy dodaæ informacjê, ¿e
wyj¹tek
PropertyVetoException ma byæ obs³ugiwany przez&nbsp; wo³aj¹cego te
metody.<br>
<br>
A wo³amy je z GUI kontrolera.<br>
Tam jest miejsce do obs³ugi tego wyj¹tku:<br>
<pre>public class CounterControlGui .... {

....
public void actionPerformed(ActionEvent e)  {
  try  {
    if (e.getSource() == txt)  {
       int n = 0;
       try  {
          n = Integer.parseInt(txt.getText());
       } catch (NumberFormatException exc)  { return; }
       counter.setCount(n);
       return;
    }
    String cmd = e.getActionCommand();
    if (cmd.equals("Increment")) counter.increment();
    else if (cmd.equals("Decrement")) counter.decrement();
    else System.out.println("Unrecognized command");
  } catch (PropertyVetoException exc)  { // ob³uga wyjatku:
      System.out.println(""+ exc);       // podanie informacji
                                         //o niedopuszczalnej zmianie wartoœci
  }
}

//...
}
</pre>W
klasie Main dodajemy fragment dotycz¹cy tworzenia obiektu klasy
CounterLimitator
(nadzorcy) i rejestrujemy go jako s³uchacza zmian w³aœciwoœci
ograniczanej:<br>
<br>
<pre>import java.beans.*;
public class Main {

 public static void main(String[] args) throws PropertyVetoException {
   Counter counter = new Counter();
   CounterView counterView = new CounterView(""+counter.getCount());
   counter.addPropertyChangeListener(counterView);

   // licznik mo¿e siê zmieniaæ od –5 do 10
   // bo Limitator zawetuje ka¿d¹ inn¹ zmianê
   CounterLimitator clim = new CounterLimitator(-5, 10);
   counter.addVetoableChangeListener(clim);

   CounterControlGui gui = new CounterControlGui(counter, counterView);
   gui.pack();
   gui.show();
  }

}
</pre>
Dzialanie programu &nbsp;(przy tym samym GUI kontrolera) zilustrujemy
komunikatami
na konsoli po kolejneych klikniêciach w przycisk "Decrement".<br>
<br>
<br>
<div class="listing100"><br>
Value changed from 0 to -1<br>
Value changed from -1 to -2<br>
Value changed from -2 to -3<br>
Value changed from -3 to -4<br>
Value changed from -4 to -5<br>
java.beans.PropertyVetoException: Niedopuszczalna zmiana wartoœci<br>
</div><br>
<br>
Jak widaæ, CounterLimitator nie dopuœci³ do zmiany wartoœci z -5 na -6.<br>
<br>
<br>
<br>
<a name="JavaBeans.5"></a><h2>5. Introspekcja</h2>
<br>
Srodowisko programistyczne, które ma umo¿liwiaæ dynamiczne
odczytywanie w³asnoœci
i funkcjonalnoœci dowolnych "podrzucanych" mu ziaren analizuje ziarna
za
pomoc¹ uniwerslanych metod introspekcji. <br>
<br>
Introspekcja kojarzy dwa mechanizmy: <br>
<ul><li>analizê komponentów za pomoc¹ metod refleksji przy za³o¿eniu,
¿e stosowane
s¹ pewne standardowe wzorce nazewnictwa, umo¿liwiaj¹ce okreœlenie&nbsp;
w³asnœciwoœci
i ich typu, metod pobierania i ustalania tych w³aœciwoœci,&nbsp;
rodzajóa zdarzeñ,&nbsp;
metod rejestracji s³uchaczy i nnych metod udostêpnianych przez dane
ziarno
"na zewn¹trz" </li><li>okreœlanie uzewnêtrznianych w³aœciwoœci i
funkcjonalnoœci ziarna na
podstawie dowolnie specyfikowanych przez twórcê ziarna elementów,
zapisywanych
w odpowiedniej dla danego ziarna klasie BeanInfo. </li></ul>
Oba mechanizmy mog¹ byæ stosowane ³¹cznie. W prostych przypadkach
(prostych
ziaren) nie ma potrzeby ¿mudnego tworzenia klasy BeanInfo, metody
refleksji
s¹ ca³kiem wystarczaj¹ce. <br>
Introspekcja za pomoc¹ metod refleksji jest mo¿liwa dziêki kontraktowi
dotycz¹cemu wzorców nazewnictwa. <br>
<br>
Dla w³aœciwoœci introspekcja okreœla pary metod <b>get...
(is...)&nbsp; -&nbsp; set...</b> z tymi samymi nazwami w³aœciwoœci i z
odpowiednimi sygnaturami. Mo¿e siê
okazaæ, ¿e niektóre w³aœciwoœci s¹ tylko do odczytu lub tylko do
zapisu.
Uwzglêdnia siê te¿ indeksowane w³asciwoœci. <br>
<br>
Dla&nbsp; okreœlenia, czy istniej¹ mo¿liwoœæ obs³ugi zdarzeñ i
jakich u¿ywane s¹ wzorce: <b>addXXXListener i removeXXXListener. </b><br>
<br>
Sam¹ introspekcje realizuje klasa <b>Introspector</b>. <br>
<br>
Introspector analizuje klasê-zarna (i nadrzêdne wobec niej klasy
oraz implementowane
interfejsy) zbieraj¹c informacje o w³aœciowoœciach, metodach,
zdarzeniach.
<br>
Informacja ta jest umieszczana w obiekcie typu <b>BeanInfo</b>
(BeanInfo jest nazw¹ interfejsu). Wobec tego obiektu mo¿emy nastêpnie
zastosowaæ metody zwracaj¹ce iinformacje o ziarnie. <br>
<br>
Np. analizê klasy-ziarna javax.swing.JButton uzyskujemy przez
nastêpuj¹ce odwo³anie: <br>
<br>
<b>BeanInfo info =
Introspector.getBeanInfo(Class.forName("javax.swing.JButton")); </b><br>
lub<br>
<b>BeanInfo info =
Introspector.getBeanInfo(javax.swing.JButton.class)); </b><br>
<br>
<br>
Nastêpnie wobec obiektu info mo¿emu zastosowaæ metody interfejsu
BeanInfo: <br>
<br>
<ul><li><b>EventSetDescriptor[]&nbsp;
getEventSetDescriptors()&nbsp; - </b>zwraca tablicê deskryptorów
zdarzeñ<b> </b></li><li><b>PropertyDescriptor[]&nbsp;
getPropertyDescriptors()&nbsp; - </b>zwraca tablicê deskryptorów
w³asnoœci<b> </b></li><li><b>MethodDescriptor[]&nbsp;&nbsp;
getMethodDescriptors()&nbsp;&nbsp;&nbsp;&nbsp; - </b>zwraca tablicê
deskryptorów metod</li><li>dla ka¿dgo deskryptora metody <b>ParameterDescriptor[]
getParameterDexriptors()</b> - zwraca tablicê deskryptorów parametrów
tej metody<br>
 </li></ul>
Zwracane tablice s¹ tablicami obiektów odpowiednich klas. Wobec tych
obiektów
stosujemy metody tych klas pozwalaj¹ce na uzyskiwanie ró¿nej konkretnej
informacji.
<br>
Np. program na poini¿szym wydruku analizuje klasê podan¹ jako
argument i wypisuje niektóre informacje o niej: <br>
<br>
<pre>import java.lang.reflect.*;
import java.beans.*;

public class BeanAnalyze {

  static void say(String s) { System.out.println(s); }

  public static void main(String[] arg) throws Exception {

    BeanInfo beanInfo = Introspector.getBeanInfo(Class.forName(arg[0]));

    PropertyDescriptor[] pd = beanInfo.getPropertyDescriptors();
    MethodDescriptor[] md = beanInfo.getMethodDescriptors();
    EventSetDescriptor[] evd = beanInfo.getEventSetDescriptors();

    say("W³aœciwoœci:");
    for (int i = 0; i &lt; pd.length; i++) {
      say(pd[i].getShortDescription());
      // getReadMethod i getWriteMethod zwracaj¹ obiekty typu Method
      say(" getter: "+ pd[i].getReadMethod());
      say(" setter: "+ pd[i].getWriteMethod());
    }

    say("\nMetody:");
    for (int i=0; i&lt;md.length; i++) {
      say(" " + md[i].getMethod());
    }

    say("\nZdarzenia:");
    for (int i = 0; i &lt; evd.length; i++) {
      say("Zdarzenie : " + evd[i].getShortDescription());
      Method[] met = evd[i].getListenerMethods();
      say("Metody obs³ugi:");
      for (int j=0; j &lt; met.length; j++)  say(" " + met[j]);
    }
  }

}
</pre>
<br>
Fragmenty (du¿ego!) wydruku z programu uruchomionego z argumentem
javax.swing.JButton:<br>
<br>
<div class="listingful"><br>
W³aœciwoœci:<br>
UI<br>
&nbsp;getter: public javax.swing.plaf.ButtonUI
javax.swing.AbstractButton.getUI()<br>
&nbsp;setter: public void
javax.swing.AbstractButton.setUI(javax.swing.plaf.ButtonUI)<br>
UIClassID<br>
&nbsp;getter: public java.lang.String javax.swing.JButton.getUIClassID()<br>
&nbsp;setter: null<br>
accessibleContext<br>
&nbsp;getter: public javax.accessibility.AccessibleContext
javax.swing.JButton.getAccessibleContext()<br>
&nbsp;setter: null<br>
action<br>
&nbsp;getter: public javax.swing.Action
javax.swing.AbstractButton.getAction()<br>
&nbsp;setter: public void
javax.swing.AbstractButton.setAction(javax.swing.Action)<br>
actionCommand<br>
&nbsp;getter: public java.lang.String
javax.swing.AbstractButton.getActionCommand()<br>
&nbsp;setter: public void
javax.swing.AbstractButton.setActionCommand(java.lang.String)<br>
actionListeners<br>
&nbsp;getter: public java.awt.event.ActionListener[]
javax.swing.AbstractButton.getActionListeners()<br>
&nbsp;setter: null<br>
actionMap<br>
&nbsp;getter: public final javax.swing.ActionMap
javax.swing.JComponent.getActionMap()<br>
&nbsp;setter: public final void
javax.swing.JComponent.setActionMap(javax.swing.ActionMap)<br>
...<br>
<br>
Metody:<br>
&nbsp;public boolean
java.awt.Component.action(java.awt.Event,java.lang.Object)<br>
&nbsp;public synchronized void
java.awt.Component.add(java.awt.PopupMenu)<br>
&nbsp;public java.awt.Component
java.awt.Container.add(java.awt.Component)<br>
&nbsp;public java.awt.Component
java.awt.Container.add(java.awt.Component,int)<br>
&nbsp;public void
java.awt.Container.add(java.awt.Component,java.lang.Object)<br>
&nbsp;public void
java.awt.Container.add(java.awt.Component,java.lang.Object,int)<br>
&nbsp;public java.awt.Component
java.awt.Container.add(java.lang.String,java.awt.Component)<br>
&nbsp;public void
javax.swing.AbstractButton.addActionListener(java.awt.event.ActionListener)<br>
...<br>
<br>
Zdarzenia:<br>
Zdarzenie : action<br>
Metody obs³ugi:<br>
&nbsp;public abstract void
java.awt.event.ActionListener.actionPerformed(java.awt.event.ActionEvent)<br>
Zdarzenie : ancestor<br>
Metody obs³ugi:<br>
&nbsp;public abstract void
javax.swing.event.AncestorListener.ancestorMoved(javax.swing.event.AncestorEvent)<br>
&nbsp;public abstract void
javax.swing.event.AncestorListener.ancestorAdded(javax.swing.event.AncestorEvent)<br>
&nbsp;public abstract void
javax.swing.event.AncestorListener.ancestorRemoved(javax.swing.event.AncestorEvent)<br>
Zdarzenie : change<br>
Metody obs³ugi:<br>
&nbsp;public abstract void
javax.swing.event.ChangeListener.stateChanged(javax.swing.event.ChangeEvent)<br>
...<br>
</div><br>
<br>
Szczerze mowi¹c, za pomoc¹ metod instrospekcji sporo mo¿na siê
dowiedziec o dostêpnych w³aœciwoœciach i metodach danej klasy.<br>
<br>
Oczywiœcie, maj¹c obiekty-metody (uzyskane z deskryptorów metod)
mozemy je
dynamicznie wyow³ywac œrodkami refleksji. Ale istnieje te¿ nieco
prostsza,
specjalnie dla JavaBean przygotowana mo¿liwoœæ dynamicznego pobierania
i
ustalania wlaœciwoœci oraz wo³ania innych metod.<br>
<br>
<br>
<a name="JavaBeans.6"></a><h2>6. Dynamiczne pobieranie i ustalanie w³aœciwoœci</h2>
W pakiecie java.beans znajdziemy dwie ciekawe klasy&nbsp; Statement i
Expression<br>
<br>
<div class="syntax">Obiekt klasy Statement tworzymy za pomoc¹
konstuktora:<br>
<br>
<b>&nbsp;&nbsp;&nbsp; Statement s = &nbsp;Statement( Object target,
<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;String methodName, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;Object[] arguments );<br>
</b><br>
a wywo³anie na jego rzecz metody <b>void execute()</b>
spowoduje wywo³anie na rzecz obiektu target metody o nazwie methodName
z argumentami podanymi w tablicy arguments<br>
<br>
Zwykle stosujemy tê procedure do ustalania w³aœciowoœci JavaBean,
ale mo¿e
ona byæ rownie¿ stosowana do wyo³ania dowolnych metod</div><br>
<br>
Klasa Expression dziedziczy klasê Statement. Czyli tu te¿ mo¿emy
wo³aæ metodê
execute(). Jednak jej g³ówne zastosowanie polega na dynamicznym
pobieraniu
w³aœciwoœci, lub - inaczej - dynamicznym wo³aniu metod, które zwracaj¹
wyniki
i uzyskiwaniu dostêpu do tych wyników. <br>
<br>
<div class="syntax">Obiekt klasy Expression tworzymy za pomoc¹
konstuktora:<br>
<br>
<b>
&nbsp;&nbsp;&nbsp; Expression e = &nbsp;Expression( Object target,<br>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; String methodName, <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; Object[] arguments );<br>
</b><br>
<ul><li>
wywo³anie na jego rzecz metody <b>void execute()</b> spowoduje
wywo³anie
na rzecz obiektu target metody o nazwie methodName z argumentami
podanymi
w tablicy arguments oraz przechowanie wyniku wywo³anej metody w
obiekcie
Expresion; wynik ten bêdzie dostêpny przez wywolanie metody Object
getValue()
na rzecz obeiktu Expressiom</li><li>samo wywo³anie metody <b>Object
getValue()</b> spowoduje ten sam efekt o ile wynik dla danego
obiektu-wyra¿enia nie zosta³ jeszcze ustalony.</li></ul>
</div><br>
<br>
Szczegó³owo komentowany program ilustruje zastosowanie tych klas.<br>
W poni¿szym przyk³adzie metody klas Statement i Expression bedziemy
stosowac
wobec obiektów klasy JButton oraz naszej w³asnej klasy TestBean, która
wygl¹da
tak:<br>
<pre>public class TestBean {

  private String[] headers;
  private int count;


  public TestBean() {
  }

  public TestBean(int n) {
    count = n;
  }

  public String[] getHeaders() {
    return headers;
  }

  public void setHeaders(String[] value) {
    headers = value;
  }

  public int getCount() {
    return count;
  }

  public void setCount(int value) {
    count = value;
  }

}
</pre><br>
Szczegó³owo komentowany program ilustruje zastosowanie klas Statement i
Expression,
daj¹c te¿ pewne dodatkowe na ich temat informacje.<br>
<pre>import java.beans.*;
import java.awt.*;
import javax.swing.*;

public class DynamicExec {

  public static void main(String[] args) throws Exception {

    Statement stmt;
    Expression expr;

    JButton b = new JButton();

    // Na rzecz przycisku wo³amy dynamicznie metodê setText
    // z argumentem "Przycisk"
    stmt = new Statement(b, "setText", new Object[] { "Przycisk" });
    stmt.execute();

    // Jaki wynik? Najpierw statyczne odwo³anie
    System.out.println("Tekst na przycisku 1: " + b.getText());

    // Teraz dynamicznie: stwórzmy wyra¿enie, którego wynikiem
    // jest wynik podanej metody z podanymi argumentami wywolanej
    // na rzecz b
    // Uwaga: brak argumentów - czyli tablica Object o rozmiarze 0
    expr = new Expression(b, "getText", new Object[0]);

    // Je¿eli wyra¿enie expr nie ma jeszcze wyniku
    // metoda getValue() wywo³uje podan¹ w wyra¿eniu metodê
    // i zwraca jej wynik; w przeciwnym razie zwraca
    // ustalony wczesniej wynik

    String txt = (String) expr.getValue();
    System.out.println("Tekst na przycisku 2: " + txt);

    // Mo¿emy te¿ stosowaæ klasy Statement i Expression
    // wobec naszych w³asnych klas JavaBeans

    TestBean tbean = new TestBean();

    // Uwaga: przy przekazywaniu argumentów i zwrocie wynikow
    // nastêpuj¹ automatyczne przeksztalcenia pomiedzy
    // typami prostymi i odpowiadaj¹cymi im klasami opakowuj¹cymi
    // np. int - Integer  - setCount wymaga argumentu int,
    // my podajemy Integer

    stmt = new Statement(tbean, "setCount",
                               new Object[] { new Integer(22) });
    stmt.execute();

    // Jaka jest teraz wartoœæ w³aœciwoœci count
    // I znowu: getCount() zwraca int, my odbieramy Integer

    expr = new Expression( tbean, "getCount", new Object[0] );
    Integer val = (Integer) expr.getValue();

    System.out.println("Wartoœæ count: " + val);

    // Czy mo¿emy dzia³aæ na tabliach? Ale¿ tak!

    stmt = new Statement(tbean, "setHeaders",
                         new Object[] { new String[] { "a", "b" } }
                        );
    stmt.execute();

    expr = new Expression(tbean, "getHeaders", new Object[0]);
    String[] hdr = (String[]) expr.getValue();

    System.out.println("Ustalone nag³ówki");
    for (int i=0; i&lt;hdr.length; i++)
       System.out.println(hdr[i]);

    // Mo¿emy nawet stworzyæ nowy obiekt
    // u¿ywaj¹c specjalnej nazwy metody - new  (oczywiœcie)

    expr = new Expression(TestBean.class, "new",
                          new Object[] { new Integer(111) }
                         );
    TestBean tb2 = (TestBean) expr.getValue();

    expr = new Expression (tb2, "getCount", new Object[0]);
    val = (Integer) expr.getValue();

    System.out.println("W nowym obiecie count = " + val);

  }
}

</pre><br>
<br>
<br>
<a name="JavaBeans.7"></a><h2>7. Serializacja JavaBeans</h2>
Oprócz zapisywania do strumieni obiektowych (ObjectOutputStream),
obiekty
JavaBeans mo¿na serializowac w postaci tekstowej, w formacie XML
(wersja
1.0, kodowanie UTF-8). Jest to nawet - w przypadku JavaBeans - bardziej
"przenoœny"
sposób utrwalania obiektów.<br>
Zapisywaniem obiektów zajmuje siê klasa XMLEncoder, a ich odtwarzaniem
-
klasa XMLDccoder. Przy tym &nbsp;stan obiektu zapisywany jest w postaci
&nbsp;zdatnej
do wykorzystania przez klasy Statement i Expression przy odtwarzaniu
tego
obiektu<br>
<br>
Najprostsze (przeznaczone wy³¹cznie dla JavaBeans) zastosowanie
tych klas pokazuje poni¿szy program.<br>
<pre>import java.beans.*;
import java.awt.*;
import javax.swing.*;
import java.io.*;

public class SerialBean {

  String fname = "test.xml";

  public SerialBean() {
    JButton b = new JButton("K¹œliwie wróbel æwierka³");
    b.setBackground(Color.red);
    b.setForeground(Color.yellow);

    try {
      XMLEncoder enc = new XMLEncoder(
                         new BufferedOutputStream(
                            new FileOutputStream(fname)
                            )
                      );
      enc.writeObject(b);
      enc.close();
    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    nowReadAndReport();
  }

  private void nowReadAndReport() {
    try {
      XMLDecoder dec = new XMLDecoder(
                          new BufferedInputStream(
                              new FileInputStream(fname)));
      Object obj = dec.readObject();
      JButton b = (JButton) obj;
      dec.close();
      System.out.println("Napis na przycisku: " + b.getText());
      System.out.println("Kolor t³a: " + b.getBackground());
      System.out.println("Kolor tekstu : " + b.getForeground());

    } catch (FileNotFoundException exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }



  public static void main(String[] args) {
    SerialBean serialbean = new SerialBean();
  }


}
</pre>Wyprowadzi
on na konsolê w³aœciw¹&nbsp; informacjê o stanie zapisanego a póŸniej
odtworzonego obiektu:<br>
<div class="listing100"><br>
Napis na przycisku: K¹œliwie wróbel æwierka³<br>
Kolor t³a: java.awt.Color[r=255,g=0,b=0]<br>
Kolor tekstu : java.awt.Color[r=255,g=255,b=0]<br>
</div><br>
<br>
Z ciekawoœci mo¿na zajrzeæ do pliku test.xml.<br>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.4.1-rc" class="java.beans.XMLDecoder"&gt;
 &lt;object class="javax.swing.JButton"&gt;
  &lt;string&gt;KÄÅ&gt;liwie wrÃ³bel Ä+wierkaÅ'&lt;/string&gt;
  &lt;void property="background"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
  &lt;void property="foreground"&gt;
   &lt;object class="java.awt.Color"&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
    &lt;int&gt;0&lt;/int&gt;
    &lt;int&gt;255&lt;/int&gt;
   &lt;/object&gt;
  &lt;/void&gt;
 &lt;/object&gt;
&lt;/java&gt;

</pre>Faktycznie,
jest do dok³adny szablon gotowy do zastosowania klas Expression
(dla metody-kostsruktora new z argumentem String) i Statement (dla
setBackground
i setForeground). Wszystko opiera siê na zachowaniu protoko³u JavaBeans.<br>
<br>
Oczywiœcie, mo¿emy w ten sposób serializowaæ obiekty prawie
wszystkich klas
Javy (bo prawie wszystkie s¹ JavaBeans) oraz&nbsp; w³asnych klas,
spe³niaj¹cych
protokó³ JavaBeans.<br>
 A nawet mo¿na uwzglêdniæ pewne odstêpstwa od
tego
protoko³u (np. inicjacjê w³aœciwoœci JavaBeans w konstruktorz, bez
u¿ycia
setterów) poprzez dostosowanie delegata "persystencji", do którego
odwo³uje
siê XMLEncoder - klasy <b>DefaultPersistanceDelegate</b>. <br>
O takim
bardziej zaawansowanym zastosowaniu, jak równie¿ o u¿yciu nas³uchu
wyj¹tków dekodowania za pomoc¹ interfejsu <b>ExceptionListener</b>
mo¿na przeczytaæ w dokumentacji API Javy.<br>
<br>
<br>
<br>
<a name="JavaBeans.8"></a><h2>8. Inne zagadnienia zwi¹zane z JavaBeans</h2>
<br>
To skrótowe wprowadzenie do JavaBeans nie wyczerpuje tematu.<br>
Warto wiêc na koniec zwróciæ uwagê na nieporuszone tu wa¿ne kwestie<br>
<ul><li>przystosowanie ziaren: klasy-edytory w³aœciwoœci u¿ywane m.in.
w œrodowiskach wizualnych </li><li>tworzenie klas BeanInfo,
opisuj¹cych informacje niedostêpn¹ metodami refleksji, </li><li>koteksty
(BeanContext) - swoiste kontenery, dostarczaj¹ce generalnych
mechanizmów i serwisów dla JavaBeans.</li></ul>
Informacje na te tematy mo¿na zanaleŸæ w dokumentacji.<br>
&nbsp;<br>
<hr></body></html>